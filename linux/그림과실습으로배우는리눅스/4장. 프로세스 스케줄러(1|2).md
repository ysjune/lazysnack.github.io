## 프로세스 스케줄러
여러 프로그램을 동시에 동작 시킴 (정확히는 동시에 동작하는 것처럼 보이게 함)  
- 하나의 CPU는 동시에 하나의 프로세스만 처리 가능
- 하나의 CPU에 여러 개의 프로세스를 실행해야 할 때는 각 프로세스를 적절한 시간으로 쪼개서 (타임 슬라이스) 번갈아 처리

### 첫 번째 실험
스케줄러의 동작 확인을 위한 실험, 1개의 논리 CPU 에서만 수행.  
(실험을 진행하는 동안에서는 시스템에서 다른 프로그램이 동작하지 않아야 정확성이 올라감. 이는 보통 설능 측정 실험을 할 때의 기본 원칙)
- 실험 4-A : 동작 프로세스 1개
- 실험 4-B : 동작 프로세스 2개
- 실험 4-C : 동작 프로세스 3개

##### 실험 4-A
1. 1개의 프로세스가 항상 동작
2. 1개의 프로세스 외에는 동작하는 프로세스가 없으므로 진행도는 단순 경과시간에 의해 비례  

##### 실험 4-B
1. 2개의 프로세스가 서로 번갈아가며 CPU 사용 (다시 말하면 동시에 사용하는 것은 아님)
2. 2개의 프로세스는 대략 같은 양의 타임 슬라이스를 가짐
3. 단위 시간별 진행도는 프로세스가 1개일 때와 비교하여 약 절반, 처리 완료까지 걸린 시간은 4-A 보다 2배  

##### 실험 4-C
1. 각 프로세스가 동시에 동작하는 일은 없음. 또한 1회마다 타임 슬라이스는 매우 적지만, 균등하게 CPU를 사용
2. 경과 시간은 프로세스가 1개 (실험 4-A)일 때보다 약 4배 걸림

##### 고찰
1. 동시에 프로세스를 여러개 실행하더라도 특정 순간에 논리 CPU에서 동작되는 프로세스는 1개 뿐
2. 첫 번째 프로세스부터 마지막 프로세스까지 한 바퀴 돌면 다시 첫 번째로 가는 라운드로빈 방식
3. 각 프로세스는 대략 같은 타임 슬라이스
4. 종료할 때 까지의 경과 시간은 프로세스 수에 비례 하여 증가  

### 컨텍스트 스위치
논리 CPU 상에서 동작하는 프로세스가 바뀌는 것을 칭함.  
어떤 프로세스가 어떤 프로그램을 실행 중이더라도 타임 슬라이스를 모두 소비하면 발생. But, foo() 직후에 바로 bar() 가 실행된다고는 보장 못함  
이 문제를 이해하면 이후에 처리 시간이 오래 걸렸을 때, 처리 자체의 문제보다는 '처리 중에 컨텍스트 스위치가 발생해서 다른 프로세스가 움직였다' 라는 관점도 가질 수 있음

### 프로세스의 상태
<pre><code>ps ax | wc -l</code></pre>  

> 실행 상태 - 현재 논리 CPU를 사용하고 있습니다.
> 실행 대기 상태 - CPU 시간이 할당되기를 기다리고 있습니다.
> 슬립 상태 - 이벤트가 발생하기를 기다리고 있으며 이벤트 발생까지는 CPU 시간을 사용하지 않습니다.
> 좀비 상태 - 프로세스가 종료된 뒤 부모 프로세스가 종료 상태를 인식할 때까지 기다리고 있습니다.

- STAT 필드의 첫 글자가 장시간 동안 D인 상태로 있다면
1. 스토리지의 I/O가 종료되지 않은 상태로 되어 있음
2. 커널 내의 뭔가 문제가 발생하고 있음

### 상태 변환
프로세스는 살아 있는 동안 실행, 실행 가능, 슬립 상태를 몇 번이고 오간다.

### idle 상태
프로세스가 CPU에서 '아무것도 하지 않는' 특수한 상태  
논리 CPU를 휴식 상태로 만들어 하나 이상의 프로세스가 실행 가능한 상태가 될 때까지 소비 전력을 낮춰 대기 상태로 만듦

### 스루풋과 레이턴시
- 스루풋 : 단위 시간당 처리된 일의 양으로 높을수록 좋습니다. (완료된 프로세스의 수 / 경과 시간)
- 레이턴시 : 각각의 처리가 시작부터 종료까지의 경과된 시간으로 짧을수록 좋습니다. (처리 종료 시간 - 처리 시작 시간)

### 논리 CPU가 여러 개 일 때의 스케쥴링
스케줄러 안의 논리 CPU를 여러 개 다루기 위해 '로드밸런서' 혹은 '글로벌 스케줄러' 라는 기능이 동작  
로드밸런서를 간단하게 설명하면, 여러 개의 논리 CPU에 프로세스를 공평하게 분배해주는 역할



