OS는 커널 이외에도 사용자 모드에서 동작하는 다양한 프로그램으로 구성  
라이브러리 형태, 단독 프로그램으로 동작 이 부분은 다양..  

시스템 콜, OS가 제공하는 라이브러리, OS가 제공하는 프로그램에 대한 설명 및 필요 이유  

## 시스템 콜
프로세스에서 커널의 도움이 필요할 때 시스템 콜을 이용해 도움 요청  
1. 프로세스 생성, 삭제
2. 메모리 확보, 해제
3. 네트워크
4. 파일 시스템
등등

## CPU의 모드 변경
프로세스는 보통 사용자 모드로 실행, 처리를 위해 시스템 콜을 호출하면 CPU 에서 인터럽트 발생  
그 후 커널 모드에서 해당 동작을 실행, 완료 후 사용자 모드로 원복  
커널 모드로 가기 전에 프로세스의 요구가 유효한지 확인을 거침 -> 맞지 않으면 시스템 콜 실패 (인터럽트를 하고, 확인을 할까? 아니면 확인 후 인터럽트일까? 아마 후자..?)  
시스템 콜 없이 직접 CPU 모드를 변경하는 방법은 존재 X

## 시스템 콜 호출의 동작 순서
프로세스가 어떤 시스템 콜을 호출했는가는 `strace` 명령어를 통해 확인 가능  
strace 각각의 줄은 1개의 시스템 콜 호출을 의미  

## 실험
프로세스가 사용자 모드와 커널 모드 중 어느 쪽에서 실행되고 있는지의 비율은 `sar` 명령어로 확인 가능  
`` sar -P ALL 1 ``  
사용자 모드에서 프로세스를 실행하는 시간의 비율 = %user + %nice  
CPU코어가 커널 모드에서 시스템 콜 등의 처리를 실행하고 있는 시간의 비율은 %system  

* 대체로 %System 수치가 크면(수십 이상) 시스템 콜이 너무 많이 호출되고 있거나, 시스템에 과부하가 걸려있는 듯 좋지 않은 상태를 의미

##시스템 콜의 wrapper 함수
시스템 콜은 보통의 함수 호출과는 다르게 C 언어 등의 고급언어에서는 직접 호출이 불가능.  
만약 OS 에 도움이 없었다면 각 프로그램은 시스템 콜을 호출할 때마다 아키텍처에 의존하는 어셈블리 언어를 써서 어셈블리 코드를 호출해야 했음.  
(이 부분도 약간의 관심은 있음. 시간이 되면 리버스 엔지니어링 책을 보자...)  
OS는 내부적으로 시스템 콜을 호출하는 일만 하는 함수를 제공하는데 이를 시스템 콜 wrapper 라고 함.  

## 표준 C 라이브러리 
(일단은 정리하는 차원에서 적는다. C라이브러리를 알아야하는지, 혹은 써먹을 일이 있는지에 관해서는 글쎄..)  
ISO 에 의해 정해진 표준 라이브러리가 존재하며, 리눅스에도 제공하고 있음.  
보통 GNU 에서 제공하는 glibc 를 표준으로 사용.  
프로그램이 어떠한 라이브러리를 링크하고 있는가는 `ldd` 명령어를 사용하여 확인 가능.  

## OS가 제공하는 프로그램
- 시스템 초기화 : init
- OS의 동작을 바꿈 : sysctl, nice, sync
- 파일 관련 : touch, mkdir
- 텍스트 데이터 가공 : grep, sort, uniq
- 성능 측정 : sar, iostat
- 컴파일러 : gcc
- 스크립트 언어 실행 환경 : perl, python, ruby
- 셸 : bash
- 윈도우 시스템 : X


음.. 일단 모르는 말 투성이라 정리는 해봤으나, 자주봐서 눈에 익히는 수 밖에 없는 것 갇다.  
주사용 언어가 자바라서 자바의 strace 를 계산해보려고 했으나, 리눅스가 안 깔려 있으므로... fail, powershell 에서 될까 싶었는데, 역시 안되더라.  
마지막에 나오는 OS 가 제공하는 프로그램에서는 사용해본 것도 있지만, 사용하지 않은 것들이 더 많으므로, 이 부분은 사용하면서 리눅스 카테고리에 정리도 할까 함..  
